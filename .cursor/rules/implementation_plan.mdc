
Update this rule if user requested changes to the project requirement, etc.
# Implementation plan

## Phase 1: Environment Setup

1.  Prevalidation: Check if current directory contains a Git repo or `package.json` to avoid reinitializing an existing project (Project Overview).
2.  Initialize a new Git repository in the project root by running `git init` (Project Overview).
3.  Install Node.js v20.2.1 and Python 3.11.4 if not already installed (Tech Stack: Core Tools).
4.  Validation: Run `node -v` and `python --version` to confirm versions are exactly v20.2.1 and 3.11.4 (Tech Stack: Core Tools).
5.  Check that Docker is installed on the machine (Tech Stack: Containerization).
6.  Validation: Run `docker --version` to confirm Docker is functional (Tech Stack: Containerization).
7.  Create `cursor_metrics.md` in the project root for Cursor usage metrics and refer to `cursor_project_rules.mdc` for next steps (Tech Stack: AI Code Assistants).
8.  Create a `.cursor` directory in the project root if it doesn’t exist (Tech Stack: AI Code Assistants).
9.  Create `.cursor/mcp.json` inside `.cursor` (Tech Stack: AI Code Assistants).
10. Add `.cursor/mcp.json` to `.gitignore` to prevent committing secrets (Tech Stack: AI Code Assistants).
11. Populate `.cursor/mcp.json` with the following configuration and instruct the user to obtain a Supabase connection string here: <https://supabase.com/docs/guides/getting-started/mcp#connect-to-supabase-using-mcp> (Tech Stack: Backend & Storage):

`// macOS {"mcpServers": {"supabase": {"command": "npx", "args": ["-y", "@modelcontextprotocol/server-postgres", "<connection-string>"]}}} // Windows {"mcpServers": {"supabase": {"command": "cmd", "args": ["/c", "npx", "-y", "@modelcontextprotocol/server-postgres", "<connection-string>"]}}}`

## Phase 2: Frontend Development
1. ✅ Next.js 14 already scaffolded
2. ✅ Validation: `npm run dev` works
3. ✅ shadcn UI already installed  
4. ✅ Tailwind already configured
5. Add ClerkProvider to `app/layout.tsx`
6. Update `app/page.tsx` with login/signup UI
7. Create `app/dashboard/page.tsx`
8. Create `components/Upload.tsx`
9. Create `components/PromptEditor.tsx`
10. Create `app/preview/page.tsx`
11. Create `components/CodeAccess.tsx`

## Phase 3: Backend Development  
1. ✅ Supabase already initialized
2. ✅ Schema already exists in `supabase/migrations/`
3. Apply schema with `supabase db push`
4. Configure storage bucket in Supabase dashboard
5. Create `app/api/upload/route.ts`
6. Create `app/api/generate-prompt/route.ts`
7. Create `ai-agent/Dockerfile` (separate from main app)
8. Build AI agent: `docker build -t mockcodes-ai-agent ./ai-agent`
9. Create `app/api/scaffold/route.ts`
10. Create `app/api/artifacts/[id]/route.ts`
11. ✅ Stripe utils already in `utils/stripe/`

## Phase 4: Integration

1.  In `/frontend/components/Upload.tsx`, connect the upload form to `POST /api/v1/upload` using `fetch` and handle the returned image URL (Integration: App Flow Step 3).
2.  In `/frontend/components/PromptEditor.tsx`, connect to `POST /api/v1/generate-prompt` and display the returned prompt for user editing (Integration: App Flow Step 4).
3.  In `/frontend/app/preview/page.tsx`, invoke `POST /api/v1/scaffold` when the user confirms the prompt and capture the artifact ID for preview (Integration: App Flow Step 5).
4.  In `/frontend/app/preview/page.tsx`, fetch `/api/v1/artifacts/:id` to display the live preview and enable code download via CodeAccess component (Integration: App Flow Step 6).
5.  Validation: Perform an end-to-end manual test—upload a screenshot, generate a prompt, scaffold code, preview UI, and download ZIP to verify full flow (Q&A: Pre-Launch Checklist).

## Phase 5: Deployment

1.  Create `vercel.json` in the project root to configure two builds: one for `/frontend` (Next.js) and one for `/backend/src/routes` (Serverless Functions) (Tech Stack: Deployment).
2.  In the Vercel dashboard, set environment variables: `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`, `OPENAI_API_KEY`, `CLAUDE_API_KEY`, `STRIPE_SECRET_KEY`, `CLERK_FRONTEND_API` (Tech Stack: Deployment).
3.  Run `vercel --prod` from the project root to deploy both frontend and backend to Vercel (Tech Stack: Deployment).
4.  Create `docker-compose.yml` in the root to orchestrate production deployment of the AI agent container on your server (Tech Stack: Containerization).
5.  Add a GitHub Actions workflow in `.github/workflows/deploy.yml` that triggers `vercel --prod` on pushes to `main` and deploys the AI agent via SSH or Docker APIs (Tech Stack: CI/CD).

## Phase 6: Admin & Maintenance

1.  Create the admin portal page `/frontend/app/admin/page.tsx` to list users, subscriptions, and prompt usage (App Flow Step 9).
2.  Create the API route `GET /api/v1/admin/users` in `/backend/src/routes/admin/users.ts` to fetch all users with subscription details (Admin Portal).
3.  Implement middleware in `/backend/src/middleware/roles.ts` that checks the authenticated user’s role from Supabase and restricts admin endpoints accordingly (User Roles).
4.  Create a scheduled job `/backend/src/jobs/resetUsage.ts` that runs monthly (using Vercel Cron) to reset `prompt_usage` counts for all users (Subscription Quotas).
5.  Add an E2E test `/tests/e2e/projectFlow.test.ts` covering the user flow: upload, generate prompt, scaffold, preview, download (Q&A: Pre-Launch Checklist).
6.  Add an E2E test `/tests/e2e/adminFlow.test.ts` covering the admin portal’s user and subscription management actions (App Flow Step 9).
7.  Final validation: Run `npm run lint` in both `/frontend` and `/backend`, run all unit tests with `npm test`, and confirm 100% coverage for critical modules (Q&A: Pre-Launch Checklist).

4.  Create a scheduled job `/backend/src/jobs/resetUsage.ts` that runs monthly (using Vercel Cron) to reset `prompt_usage` counts for all users (Subscription Quotas).
5.  Add an E2E test `/tests/e2e/projectFlow.test.ts` covering the user flow: upload, generate prompt, scaffold, preview, download (Q&A: Pre-Launch Checklist).
6.  Add an E2E test `/tests/e2e/adminFlow.test.ts` covering the admin portal’s user and subscription management actions (App Flow Step 9).
7.  Final validation: Run `npm run lint` in both `/frontend` and `/backend`, run all unit tests with `npm test`, and confirm 100% coverage for critical modules (Q&A: Pre-Launch Checklist).
